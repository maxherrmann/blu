/**
 * Blu 1.3.1 (ESM Minified) | Mon, 14 Nov 2022 14:18:28 GMT
 * Copyright (c) 2022 Max Herrmann
 * https://github.com/maxherrmann/blu/blob/main/LICENSE
 */
var e={411:(e,t,r)=>{const i=r(122);e.exports=new class Bluetooth extends i{#e=new Set;#t=!1;constructor(){super(!0),this.addChannel("bluetooth-enabled"),this.addChannel("bluetooth-disabled"),this.addChannel("device-connected"),this.addChannel("device-connection-lost"),this.addChannel("device-disconnected"),this.isSupported&&(globalThis.navigator.bluetooth.addEventListener("availabilitychanged",(e=>{this.emit(e.value?"bluetooth-enabled":"bluetooth-disabled")})),this.on("bluetooth-disabled",(()=>{this.#e.clear()})),this.on("device-connected",(e=>{this.#e.add(e)})),this.on("device-disconnected",(e=>{this.#e.delete(e)})))}get isSupported(){return!!globalThis.navigator?.bluetooth}get isDataTransferLoggingEnabled(){return this.#t}get connectedDevices(){return Array.from(this.#e)}get connectedDevice(){return this.connectedDevices[this.connectedDevices.length-1]??null}isAvailable(){return new Promise((e=>{this.isSupported?globalThis.navigator.bluetooth.getAvailability().then((t=>{e(t)})):e(!1)}))}enableDataTransferLogging(){this.#t=!0}disableDataTransferLogging(){this.#t=!1}}},982:(e,t,r)=>{const i=r(259),s=r(411),n=r(4),o=r(472),a=r(655),c=r(122),h=r(62),u=r(701);const l=5e3;class CharacteristicProperties{read;write;writeWithoutResponse;notify;constructor(e){this.read=e.read,this.write=e.write,this.writeWithoutResponse=e.writeWithoutResponse,this.notify=e.notify,this.notify&&(this.isListening=!1)}get string(){return this.toString()}toString(){return[this.read?"R":"-",this.write?"W":"-",this.writeWithoutResponse?"w":"-",this.notify?"N":"-"].join("")}}class CharacteristicOperationError extends a{characteristic;constructor(e,t,r){super(t,r),this.characteristic=e}}class NotificationTimeoutError extends a{}e.exports=class Characteristic extends c{service;description;properties;descriptors;responseType=o;_bluetoothCharacteristic;constructor(e,t,r){super(),this.service=e,this.description=r,this.properties=new CharacteristicProperties(t.properties),this.descriptors=[],this._bluetoothCharacteristic=t,this.on("notification",(e=>{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Notification received:`,e)}))}get uuid(){return this._bluetoothCharacteristic.uuid}get value(){return this._bluetoothCharacteristic.value}get hasExpectedProperties(){return this.properties.string===this.description.expectedIndicators}async onceReady(){}readValue(){return new Promise((async(e,t)=>{if(this.properties.read)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.readValue())),s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Read value:`,this.value),e(this.value)}catch(e){t(new CharacteristicOperationError(this,"Cannot read value.",e))}else t(new CharacteristicOperationError(this,"Cannot read from a non-readable characteristic."))}))}read(e){return new Promise((async(t,r)=>{if("string"==typeof e)try{let r=await this.readValue();t(new this.responseType(r)[e])}catch(e){r(e)}else r(new CharacteristicOperationError(this,'Argument "responseProperty" must be of type "string".'))}))}write(e,t=!1){return new Promise((async(r,n)=>{if(!t||this.properties.writeWithoutResponse)if(t||this.properties.write){if(!u(e))if(h(e)){if(!e.every((e=>"number"==typeof e)))return void n(new CharacteristicOperationError(this,'Argument "value" must be an array of items that are all of type "number".'));e=new Uint8Array(e)}else{if("number"!=typeof e)return void n(new CharacteristicOperationError(this,'Argument "value" must be of type "number".'));e=new Uint8Array([e])}try{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Write:`,e),t?await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.writeValueWithoutResponse(e))):await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.writeValueWithResponse(e))),r()}catch(e){n(new CharacteristicOperationError(this,"Cannot write value.",e))}}else n(new CharacteristicOperationError(this,"Cannot write to a non-writable characteristic."));else n(new CharacteristicOperationError(this,"Cannot write without response to a characteristic that is not writable without response."))}))}request(e,t=l){return new Promise((async(r,o)=>{if(!(e instanceof n))return void o(new CharacteristicOperationError(this,`Argument "request" must be a valid instance of "Request". Got "${e?.constructor.name}".`));if(null!=t&&"number"!=typeof t)return void o(new CharacteristicOperationError(this,'Argument "timeout" must be either "undefined", "null" or of type "number". '));s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Request:`,e);let a=t=>{e.responseType.validatorFunction(t)&&(clearTimeout(c),this.off("notification",a),r(new e.responseType(t.data)))};if(this.on("notification",a),t)var c=setTimeout((()=>{this.off("notification",a),o(new NotificationTimeoutError(`Did not receive an expected notification from the device within ${t} ms.`))}),t);this.write(e.data).catch((e=>{clearTimeout(c),this.off("notification",a),o(new CharacteristicOperationError(this,"Cannot request from characteristic.",e))}))}))}requestAll(e,t=l){return new Promise((async(r,i)=>{if(h(e)&&e.every((e=>e instanceof n)))if(null==t||"number"==typeof t)try{let i=[];for(const r of e)i.push(await this.request(r,t));r(i)}catch(e){i(e)}else i(new CharacteristicOperationError(this,'Argument "timeout" must be either "undefined", "null" or of type "number". '));else i(new CharacteristicOperationError(this,'Argument "requests" must be an array of instances of "Request".'))}))}startListeningForNotifications(){return new Promise((async(e,t)=>{if(this.properties.notify)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.startNotifications())),this._bluetoothCharacteristic.addEventListener("characteristicvaluechanged",this.#r.bind(this)),this.properties.isListening=!0,i.debug("Started listening for notifications.",this),e()}catch(e){t(new CharacteristicOperationError(this,"Cannot start listening to characteristic.",e))}else t(new CharacteristicOperationError(this,"Cannot start listening to a non-notifying characteristic."))}))}stopListeningForNotifications(){return new Promise((async(e,t)=>{if(this.properties.isListening)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.stopNotifications())),this._bluetoothCharacteristic.removeEventListener("characteristicvaluechanged",this.#r.bind(this)),this.properties.isListening=!1,i.debug("Stopped listening for notifications.",this),e()}catch(e){t(new CharacteristicOperationError(this,"Cannot stop listening to characteristic.",e))}else t(new CharacteristicOperationError(this,"Cannot stop listening to a characteristic that is not yet listened to."))}))}#r(){this.emit("notification",new this.responseType(this.value))}}},976:(e,t,r)=>{const i=r(83),s=r(655),n=r(383);class BluConfigurationError extends s{}e.exports=new class Configuration{#i;#s;#n;#o;constructor(){this.restoreDefaults()}get scannerConfig(){return this.#i}get deviceType(){return this.#s}get ensureCompleteDeviceBluetoothInterface(){return this.#n}get autoListenToNotifiableCharacteristics(){return this.#o}restoreDefaults(){this.#i={acceptAllDevices:!0},this.#s=i,this.#n=!0,this.#o=!0}use(e,t){e&&this.useScannerConfig(e),t&&this.useDeviceType(t)}useScannerConfig(e){if("object"!=typeof e)throw new BluConfigurationError('Argument "scannerConfig" must be an object.');this.#i=e}useDeviceType(e){if(!n(e,i))throw new BluConfigurationError('Argument "deviceType" must be a class that is or extends "Device".');this.#s=e}set(e){if("object"!=typeof e)throw new BluConfigurationError('Argument "configuration" must be an object.');if(!Object.getOwnPropertyNames(e).every((e=>["ensureCompleteDeviceBluetoothInterface","autoListenToNotifiableCharacteristics"].includes(e))))throw new BluConfigurationError('Argument "configuration" must contain an object with valid configuration options.');if(Object.hasOwn(e,"ensureCompleteDeviceBluetoothInterface")){if("boolean"!=typeof e.ensureCompleteDeviceBluetoothInterface)throw new BluConfigurationError('Configuration property "ensureCompleteDeviceBluetoothInterface" must be of type "boolean".');this.#n=e.ensureCompleteDeviceBluetoothInterface}if(Object.hasOwn(e,"autoListenToNotifiableCharacteristics")){if("boolean"!=typeof e.autoListenToNotifiableCharacteristics)throw new BluConfigurationError('Configuration property "autoListenToNotifiableCharacteristics" must be of type "boolean".');this.#o=e.autoListenToNotifiableCharacteristics}}}},257:(e,t,r)=>{const i=r(948),s=r(982),n=r(530),o=r(62),a=r(383),c=r(655);class Description{uuid;identifier;name;constructor(e,t=null,r="Unspecified Entity"){if("string"!=typeof e&&"number"!=typeof e)throw new DescriptionConstructionError('Argument "uuid" must be either of type "string" or "number".');if("string"==typeof e&&(e=e.toLowerCase()),null!==t&&"string"!=typeof t)throw new DescriptionConstructionError('Argument "identifier" must be either "null" or of type "string".');if("string"!=typeof r)throw new DescriptionConstructionError('Argument "name" must be of type "string".');this.uuid=e,this.identifier=t,this.name=r}}class CharacteristicDescription extends Description{type;descriptors;expectedIndicators;constructor(e,t,r="Unspecified Characteristic",i=s,n=[],c=null){if(super(e,t,r),!a(i,s))throw new CharacteristicDescriptionConstructionError('Argument "type" must be a class that is or extends "Characteristic".');if(!o(n)||!n.every((e=>e instanceof DescriptorDescription)))throw new CharacteristicDescriptionConstructionError('Argument "descriptorDescriptions" must be an array of "DescriptorDescription".');if(null!==c&&"string"!=typeof c)throw new CharacteristicDescriptionConstructionError('Argument "expectedIndicators" must be either "null" or of type "string".');if("string"==typeof c&&!c.match(/^[R-][W-][w-][N-]$/))throw new CharacteristicDescriptionConstructionError('Argument "expectedIndicators" contains a string that is incorrectly formatted.');this.type=i,this.descriptors=n,this.expectedIndicators=c??null}}class DescriptorDescription extends Description{type;constructor(e,t=null,r="Unspecified Descriptor",i=n){if(super(e,t,r),!a(i,n))throw new DescriptorDescriptionConstructionError('Argument "type" must be a class that is or extends "Descriptor".');this.type=i}}class DescriptionConstructionError extends c{}class ServiceDescriptionConstructionError extends c{}class CharacteristicDescriptionConstructionError extends c{}class DescriptorDescriptionConstructionError extends c{}e.exports={ServiceDescription:class ServiceDescription extends Description{type;characteristics;constructor(e,t,r="Unspecified Service",s=i,n=[]){if(super(e,t,r),!a(s,i))throw new ServiceDescriptionConstructionError('Argument "type" must be a class that is or extends "Service".');if(!o(n)||!n.every((e=>e instanceof CharacteristicDescription)))throw new ServiceDescriptionConstructionError('Argument "characteristicDescriptions" must be an array of "CharacteristicDescription".');this.type=s,this.characteristics=n}},CharacteristicDescription,DescriptorDescription}},530:(e,t,r)=>{const i=r(259),s=r(411),n=r(472),o=r(655),a=r(62),c=r(701);class DescriptorOperationError extends o{descriptor;constructor(e,t,r){super(t,r),this.descriptor=e}}e.exports=class Descriptor{characteristic;description;responseType=n;_bluetoothDescriptor;constructor(e,t,r){this.characteristic=e,this.description=r,this._bluetoothDescriptor=t}get uuid(){return this._bluetoothDescriptor.uuid}get value(){return this._bluetoothDescriptor.value}async onceReady(){}readValue(){return new Promise((async(e,t)=>{try{await this.characteristic.service.device.performGATTOperation((()=>this._bluetoothDescriptor.readValue())),s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Read value:`,this.value),e(this.value)}catch(e){t(new DescriptorOperationError(this,"Cannot read value.",e))}}))}read(e){return new Promise((async(t,r)=>{if("string"==typeof e)try{let r=await this.readValue();t(new this.responseType(r)[e])}catch(e){r(e)}else r(new DescriptorOperationError(this,'Argument "responseProperty" must be of type "string".'))}))}write(e){return new Promise((async(t,r)=>{if(!c(e))if(a(e)){if(!e.every((e=>"number"==typeof e)))return void r(new DescriptorOperationError(this,'Argument "value" must be an array of items that are all of type "number".'));e=new Uint8Array(e)}else{if("number"!=typeof e)return void r(new DescriptorOperationError(this,'Argument "value" must be of type "number".'));e=new Uint8Array([e])}try{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Write:`,e),await this.characteristic.service.device.performGATTOperation((()=>this._bluetoothDescriptor.writeValue(e))),t()}catch(e){r(new DescriptorOperationError(this,"Cannot write value.",e))}}))}}},83:(e,t,r)=>{const i=r(259),s=r(976),n=r(411),o=r(948),a=r(982),c=r(530),h=r(893),{ServiceDescription:u,CharacteristicDescription:l,DescriptorDescription:d}=r(257),p=r(655),f=r(122);class DeviceOperationError extends p{}class DeviceConnectionError extends p{}class DeviceBluetoothInterfaceDiscoveryError extends p{}class DeviceBluetoothInterfaceIncompleteError extends p{}class DescriptorDiscoveryError extends p{}e.exports=class Device extends f{id;name;properties;services=[];serviceDescriptions=[];_bluetoothDevice;#a=new h;#c=!1;constructor(e){super(!0),this.id=e.id,this.name=e.name,this._bluetoothDevice=e,this.addChannel("advertised"),this.addChannel("connected"),this.addChannel("connection-lost"),this.addChannel("disconnected"),this.#h()}get characteristics(){let e=[];for(const t of this.services)e.push(...t.characteristics);return e}get isConnected(){return this._bluetoothDevice.gatt.connected}async onceReady(){}connect(){return new Promise((async(e,t)=>{try{await this._bluetoothDevice.gatt.connect()}catch(e){return void t(new DeviceConnectionError("Could not connect to device.",e))}try{await this.#u(),this._bluetoothDevice.addEventListener("gattserverdisconnected",this.#l.bind(this),{once:!0}),this._bluetoothDevice.addEventListener("gattserverdisconnected",this.#d.bind(this),{once:!0}),await this.onceReady(),this.emit("connected"),e()}catch(e){t(e)}}))}disconnect(){return new Promise((async(e,t)=>{this.#c=!0;try{await this._bluetoothDevice.gatt.disconnect(),e()}catch(e){t(new DeviceConnectionError("Could not disconnect from device.",e))}this.#c=!1}))}performGATTOperation(e){return this.#a.await(e)}async#h(){if(this.on("connected",(()=>{i.log("Connected.",this),n.emit("device-connected",this)})),this.on("connection-lost",(()=>{i.warn("Connection lost.",this),n.emit("device-connection-lost",this)})),this.on("disconnected",(()=>{i.log("Disconnected.",this),n.emit("device-disconnected",this)})),"function"==typeof this._bluetoothDevice.watchAdvertisements)try{this._bluetoothDevice.addEventListener("advertisementreceived",(e=>{this.emit("advertised",e)})),await this._bluetoothDevice.watchAdvertisements()}catch(e){i.warn(new DeviceOperationError("Could not start watching for advertisements.",e))}}async#u(){return new Promise((async(e,t)=>{try{let t=!1;for(const e of this.serviceDescriptions){let r;try{r=new e.type(this,await this._bluetoothDevice.gatt.getPrimaryService(e.uuid),e),r.description.identifier&&(this[r.description.identifier]=r),this.services.push(r)}catch(r){t=!0,i.warn(`Could not discover "${e.name}" (${e.uuid}).`,this)}if(r)for(const s of e.characteristics){let n;try{n=new s.type(r,await r._bluetoothService.getCharacteristic(s.uuid),s),n.description.identifier&&(r[n.description.identifier]=n),r.characteristics.push(n)}catch(r){t=!0,i.warn(`Could not discover "${s.name}" (${s.uuid}) in "${e.name}" (${e.uuid}).`,this)}if(n)for(const e of s.descriptors){let r;try{r=new e.type(n,await n._bluetoothCharacteristic.getDescriptor(e.uuid),e),r.description.identifier&&(n[r.description.identifier]=r),n.descriptors.push(r)}catch(r){t=!0,i.warn(`Could not discover "${e.name}" (${e.uuid}) in "${s.name}" (${s.uuid}).`,this)}}}}if(s.ensureCompleteDeviceBluetoothInterface&&t)throw new DeviceBluetoothInterfaceIncompleteError('The device’s Bluetooth interface is incomplete. Make sure that your service descriptions are correct or configure Blu to ignore incomplete device Bluetooth interfaces by setting the configuration property "ensureCompleteDeviceBluetoothInterface" to "false" before calling "device.connect()".');let h=await this._bluetoothDevice.gatt.getPrimaryServices();for(let e of h){e=new o(this,e,new u(e.uuid)),this.services.find((t=>t.uuid===e.uuid))||this.services.push(e);let t=await e._bluetoothService.getCharacteristics();for(let r of t){r=new a(e,r,new l(r.uuid)),e.characteristics.find((e=>e.uuid===r.uuid))||e.characteristics.push(r);try{var n=await r._bluetoothCharacteristic.getDescriptors()}catch(e){if("NotFoundError"!==e.name)throw new DescriptorDiscoveryError(`Could not discover descriptors of characteristic with UUID "${r.uuid}".`,e);n=[]}for(let e of n)e=new c(r,e,new d(e.uuid)),r.descriptors.find((t=>t.uuid===e.uuid))||r.descriptors.push(e)}}const{autoListenToNotifiableCharacteristics:p}=r(976);for(const e of this.services){for(const t of e.characteristics){t.properties.notify&&p&&await t.startListeningForNotifications();for(const e of t.descriptors)await e.onceReady();await t.onceReady()}await e.onceReady()}e()}catch(e){t(new DeviceBluetoothInterfaceDiscoveryError("Could not discover the device’s Bluetooth interface.",e))}}))}#d(){this.#c||this.emit("connection-lost")}#l(){this.emit("disconnected")}}},893:(e,t,r)=>{const i=r(122),s=r(655);class GATTOperationQueueError extends s{}class GATTOperationError extends s{}e.exports=class GATTOperationQueue extends i{#p=5e3;#f=!1;get isBusy(){return this.#f}await(e){return new Promise((async(t,r)=>{if("function"!=typeof e)return void r(new GATTOperationQueueError('Argument "callback" must be of type "function".'));await this.#g();let i=setTimeout((()=>{r(new GATTOperationError(`GATT operation timed out after ${this.#p} ms.`))}),this.#p);this.#f=!0,this.emit("gatt-operation-started"),e().then((e=>{t(e)})).catch((e=>{r(e)})).finally((()=>{clearTimeout(i),this.#f=!1,this.emit("gatt-operation-finished")}))}))}#g(){return new Promise((e=>{this.#f?this.once("gatt-operation-finished",e):e()}))}}},259:(e,t,r)=>{const i=r(148);e.exports=new i},4:(e,t,r)=>{const i=r(472),s=r(655),n=r(701);class RequestConstructionError extends s{}e.exports=class Request{responseType=i;data;constructor(...e){if(0===e.length)throw new RequestConstructionError('Argument "data" is required.');if(n(e[0])&&void 0===e[1])this.data=e[0];else{if(!e.every((e=>"number"==typeof e)))throw new RequestConstructionError('Argument "data" must be an array of items that are all of type "number".');this.data=new Uint8Array(e)}}}},472:(e,t,r)=>{const i=r(655),s=r(701);class ResponseConstructionError extends i{}e.exports=class Response{data;constructor(e){if(null!=e&&!s(e))throw new ResponseConstructionError(`Argument "data" must be either "undefined", "null" or a concrete type of "TypedArray". Got "${e?.constructor.name}" instead.`);this.data=e??null}static validatorFunction(e){return!0}}},812:(e,t,r)=>{const i=r(411),s=r(655);class ScannerError extends s{}e.exports=new class Scanner{getDevice(){return new Promise((async(e,t)=>{if(i.isSupported)try{const{scannerConfig:t,deviceType:i}=r(976);let s=await globalThis.navigator.bluetooth.requestDevice(t);s=void 0===s?null:new i(s),e(s)}catch(r){"NotFoundError"===r.name?e(null):t(new ScannerError("An error occurred.",r))}else t(new s("Blu is not compatible with this browser."))}))}getPairedDevices(){return new Promise((async(e,t)=>{if("function"==typeof globalThis.navigator?.bluetooth?.getDevices)try{e(await globalThis.navigator.bluetooth.getDevices())}catch(e){t(new ScannerError("An error occurred.",e))}else t(new ScannerError("This feature is not supported by this browser."))}))}}},948:(e,t,r)=>{const i=r(122);e.exports=class Service extends i{device;description;characteristics;_bluetoothService;constructor(e,t,r){super(),this.device=e,this.description=r,this.characteristics=[],this._bluetoothService=t}get uuid(){return this._bluetoothService.uuid}async onceReady(){}}},345:e=>{e.exports="1.3.1"},655:e=>{class BluError extends Error{constructor(e,t){super(e,{cause:t}),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,t&&(this.message+=` // ${t.name}: ${t.message}`)}}e.exports=BluError},122:(e,t,r)=>{const i=r(259),s=r(655);class EventEmitterError extends s{}e.exports=class EventEmitter{#m;#w=new Map;#v=new Set;constructor(e=!1){if("boolean"!=typeof e)throw new EventEmitterError('Argument "strictMode" must be of type "boolean".');this.#m=e}emit(e,...t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(this.#m&&!this.#w.has(e))throw new EventEmitterError(`"${e}" is not a valid channel. Add it manually or disable strict mode.`);if(this.#w.has(e)||this.#w.set(e,new Set),this.#v.has(e))i.debug(`Suppressed event for the muted channel "${e}".`,this);else for(const r of this.#w.get(e))r(...t)}on(e,t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if("function"!=typeof t)throw new EventEmitterError('Argument "callback" must be of type "function".');if(this.#m&&!this.#w.has(e))throw new EventEmitterError(`"${e}" is not a valid channel. Add it manually or disable strict mode.`);this.#w.has(e)||this.#w.set(e,new Set),this.#w.set(e,this.#w.get(e).add(t))}once(e,t){let r=(...i)=>{this.off(e,r),t(...i)};this.on(e,r)}muteChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(!this.#w.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#v.has(e)?i.warn(`The channel "${e}" is already muted.`,this):this.#v.add(e)}unmuteChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(!this.#w.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#v.has(e)?this.#v.delete(e):i.warn(`The channel "${e}" is already unmuted.`,this)}off(e,t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if("function"!=typeof t)throw new EventEmitterError('Argument "callback" must be of type "function".');if(!this.#w.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#w.get(e).delete(t)||i.warn(`Cannot remove the function in argument "callback", as it is not yet registered for "${e}".`,this)}addChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');this.#w.has(e)?i.warn(`The channel "${e}" already exists.`,this):this.#w.set(e,new Set)}removeChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');this.#w.has(e)?this.#w.delete(e):i.warn(`The channel "${e}" does not exist.`,this)}removeAllListeners(e){if(void 0!==e&&"string"!=typeof e)throw new EventEmitterError('Argument "channel" must be either "undefined" or of type "string".');e?this.#w.has(e)?this.#w.set(e,new Set):i.warn(`The channel "${e}" does not exist.`,this):this.#w.clear()}}},62:e=>{e.exports=function(e){return Array.isArray(e)}},383:e=>{e.exports=function(e,t){return e.prototype instanceof t||e===t}},701:e=>{e.exports=function(e){return ArrayBuffer.isView(e)}},148:(e,t,r)=>{const i=r(655);const s=new Intl.DateTimeFormat("en-US",{hour12:!1,hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3});class LoggerError extends i{}e.exports=class Logger{includeTimestamps=!1;includeLevelNames=!1;#b="";#y=0;#E=console;#D=!0;get isEnabled(){return this.#D}get target(){return this.#E}enable(){this.#D&&this.warn("Already enabled.",this),this.#D=!0}disable(){this.#D||this.warn("Already disabled.",this),this.#D=!1}setPrefix(e){if("string"!=typeof e)throw new LoggerError('Argument "prefix" must be of type "string".');this.#b=e}setPrefix(e){if("string"!=typeof e)throw new LoggerError('Argument "prefix" must be of type "string".');this.#b=e}setLevel(e){if("string"!=typeof e||!["debug","log","warn","error"].includes(e))throw new LoggerError('Argument "level" must be of type "string" and be one of the following: "debug", "log", "warn" or "error".');switch(e){case"debug":this.#y=0;break;case"log":this.#y=1;break;case"warn":this.#y=2;break;case"error":this.#y=3}}setTarget(e){if("object"!=typeof e||"function"!=typeof e.log||"function"!=typeof e.debug||"function"!=typeof e.warn||"function"!=typeof e.error)throw new LoggerError('Argument "consoleLike" must be an object that implements the following functions: "log", "debug", "warn" and "error".');this.#E=e}debug(e,t){!this.#D||this.#y>0||this.#E.debug(this.#C(t,"debug")+e)}log(e,t){!this.#D||this.#y>1||this.#E.log(this.#C(t,"log")+e)}warn(e,t){!this.#D||this.#y>2||this.#E.warn(this.#C(t,"warn")+e)}error(e,t){this.#D&&this.#E.error(this.#C(t,"error")+e)}#C(e,t){let r="";return this.includeTimestamps&&(r+=`[${s.format(Date.now())}] `),this.includeLevelNames&&(r+=`[${t}] `),this.#b.length>0&&(r+=`[${this.#b}] `),"string"==typeof e?r+=`${e}: `:e?.constructor?r+=`${e.constructor.name}: `:e?.name&&(r+=`${e.name}: `),r}}}},t={};function r(i){var s=t[i];if(void 0!==s)return s.exports;var n=t[i]={exports:{}};return e[i](n,n.exports,r),n.exports}r.d=(e,t)=>{for(var i in t)r.o(t,i)&&!r.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var i={};(()=>{r.d(i,{$9:()=>d,AS:()=>g,DN:()=>t,HM:()=>f,Rq:()=>c,SS:()=>h,ZP:()=>w,bw:()=>e,cc:()=>a,cf:()=>p,et:()=>n,i8:()=>o,iN:()=>m,kg:()=>s,s0:()=>l,t6:()=>u});const e=r(411),t=r(976),s=r(259),n=r(812),o=r(345),{ServiceDescription:a,CharacteristicDescription:c,DescriptorDescription:h}=r(257),u=r(948),l=r(982),d=r(530),p=r(4),f=r(472),g=r(83),m=r(655),w={bluetooth:e,configuration:t,logger:s,scanner:n,version:o,ServiceDescription:a,CharacteristicDescription:c,DescriptorDescription:h,Service:u,Characteristic:l,Descriptor:d,Device:g,Request:p,Response:f,BluError:m}})();var s=i.iN,n=i.s0,o=i.Rq,a=i.$9,c=i.SS,h=i.AS,u=i.cf,l=i.HM,d=i.t6,p=i.cc,f=i.bw,g=i.DN,m=i.ZP,w=i.kg,v=i.et,b=i.i8;export{s as BluError,n as Characteristic,o as CharacteristicDescription,a as Descriptor,c as DescriptorDescription,h as Device,u as Request,l as Response,d as Service,p as ServiceDescription,f as bluetooth,g as configuration,m as default,w as logger,v as scanner,b as version};
//# sourceMappingURL=blu.esm.min.js.map