/**
 * Blu 1.1.0 (UMD Minified) | Tue, 12 Jul 2022 11:36:46 GMT
 * Copyright (c) 2022 Max Herrmann
 * https://github.com/maxherrmann/blu/blob/main/LICENSE
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.blu=t():e.blu=t()}(this,(()=>{return e={920:(e,t,r)=>{e.exports={bluetooth:r(411),configuration:r(976),logger:r(259),scanner:r(812),version:r(345),ServiceDescription:r(257).ServiceDescription,CharacteristicDescription:r(257).CharacteristicDescription,DescriptorDescription:r(257).DescriptorDescription,Service:r(948),Characteristic:r(982),Descriptor:r(530),Device:r(83),Request:r(4),Response:r(472),BluError:r(655)}},411:(e,t,r)=>{const i=r(122);e.exports=new class Bluetooth extends i{#e=new Set;#t=!1;constructor(){super(!0),this.addChannel("bluetooth-enabled"),this.addChannel("bluetooth-disabled"),this.addChannel("device-connected"),this.addChannel("device-connection-lost"),this.addChannel("device-disconnected"),this.isSupported&&(globalThis.navigator.bluetooth.addEventListener("availabilitychanged",(e=>{this.emit(e.value?"bluetooth-enabled":"bluetooth-disabled")})),this.on("bluetooth-disabled",(()=>{this.#e.clear()})),this.on("device-connected",(e=>{this.#e.add(e)})),this.on("device-disconnected",(e=>{this.#e.delete(e)})))}get isSupported(){return!!globalThis.navigator?.bluetooth}get isDataTransferLoggingEnabled(){return this.#t}get connectedDevices(){return Array.from(this.#e)}get connectedDevice(){return this.connectedDevices[this.connectedDevices.length-1]??null}isAvailable(){return new Promise((e=>{this.isSupported?globalThis.navigator.bluetooth.getAvailability().then((t=>{e(t)})):e(!1)}))}enableDataTransferLogging(){this.#t=!0}disableDataTransferLogging(){this.#t=!1}}},982:(e,t,r)=>{const i=r(259),s=r(411),n=r(4),o=r(472),a=r(655),c=r(122),h=r(62),u=r(701),l=5e3;class CharacteristicProperties{read;write;writeWithoutResponse;notify;constructor(e){this.read=e.read,this.write=e.write,this.writeWithoutResponse=e.writeWithoutResponse,this.notify=e.notify,this.notify&&(this.isListening=!1)}get string(){return this.toString()}toString(){return[this.read?"R":"-",this.write?"W":"-",this.writeWithoutResponse?"w":"-",this.notify?"N":"-"].join("")}}class CharacteristicOperationError extends a{characteristic;constructor(e,t,r){super(t,r),this.characteristic=e}}class NotificationTimeoutError extends a{}e.exports=class Characteristic extends c{service;description;properties;descriptors;responseType=o;_bluetoothCharacteristic;constructor(e,t,r){super(),this.service=e,this.description=r,this.properties=new CharacteristicProperties(t.properties),this.descriptors=[],this._bluetoothCharacteristic=t,this.on("notification",(e=>{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Notification received:`,e)}))}get uuid(){return this._bluetoothCharacteristic.uuid}get value(){return this._bluetoothCharacteristic.value}get hasExpectedProperties(){if(void 0!==this.description)return this.properties.string===this.description.expectedIndicators}async onceReady(){}readValue(){return new Promise((async(e,t)=>{if(this.properties.read)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.readValue())),s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Read value:`,this.value),e(this.value)}catch(e){t(new CharacteristicOperationError(this,"Cannot read value.",e))}else t(new CharacteristicOperationError(this,"Cannot read from a non-readable characteristic."))}))}read(e){return new Promise((async(t,r)=>{if("string"==typeof e)try{let r=await this.readValue();t(new this.responseType(r)[e])}catch(e){r(e)}else r(new CharacteristicOperationError(this,'Argument "responseProperty" must be of type "string".'))}))}write(e,t=!1){return new Promise((async(r,n)=>{if(!t||this.properties.writeWithoutResponse)if(t||this.properties.write){if(!u(e))if(h(e)){if(!e.every((e=>"number"==typeof e)))return void n(new CharacteristicOperationError(this,'Argument "value" must be an array of items that are all of type "number".'));e=new Uint8Array(e)}else{if("number"!=typeof e)return void n(new CharacteristicOperationError(this,'Argument "value" must be of type "number".'));e=new Uint8Array([e])}try{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Write:`,e),t?await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.writeValueWithoutResponse(e))):await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.writeValueWithResponse(e))),r()}catch(e){n(new CharacteristicOperationError(this,"Cannot write value.",e))}}else n(new CharacteristicOperationError(this,"Cannot write to a non-writable characteristic."));else n(new CharacteristicOperationError(this,"Cannot write without response to a characteristic that is not writable without response."))}))}request(e,t=l){return new Promise((async(r,o)=>{if(!(e instanceof n))return void o(new CharacteristicOperationError(this,`Argument "request" must be a valid instance of "Request". Got "${e?.constructor.name}".`));if(null!=t&&"number"!=typeof t)return void o(new CharacteristicOperationError(this,'Argument "timeout" must be either "undefined", "null" or of type "number". '));s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Request:`,e);let a=t=>{e.responseType.validatorFunction(t)&&(clearTimeout(c),this.off("notification",a),r(new e.responseType(t.data)))};if(this.on("notification",a),t)var c=setTimeout((()=>{this.off("notification",a),o(new NotificationTimeoutError(`Did not receive an expected notification from the device within ${t} ms.`))}),t);this.write(e.data).catch((e=>{clearTimeout(c),this.off("notification",a),o(new CharacteristicOperationError(this,"Cannot request from characteristic.",e))}))}))}requestAll(e,t=l){return new Promise((async(r,i)=>{if(h(e)&&e.every((e=>e instanceof n)))if(null==t||"number"==typeof t)try{let i=[];for(const r of e)i.push(await this.request(r,t));r(i)}catch(e){i(e)}else i(new CharacteristicOperationError(this,'Argument "timeout" must be either "undefined", "null" or of type "number". '));else i(new CharacteristicOperationError(this,'Argument "requests" must be an array of instances of "Request".'))}))}startListeningForNotifications(){return new Promise((async(e,t)=>{if(this.properties.notify)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.startNotifications())),this._bluetoothCharacteristic.addEventListener("characteristicvaluechanged",this.#r.bind(this)),this.properties.isListening=!0,i.debug("Started listening for notifications.",this),e()}catch(e){t(new CharacteristicOperationError(this,"Cannot start listening to characteristic.",e))}else t(new CharacteristicOperationError(this,"Cannot start listening to a non-notifying characteristic."))}))}stopListeningForNotifications(){return new Promise((async(e,t)=>{if(this.properties.isListening)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.stopNotifications())),this._bluetoothCharacteristic.removeEventListener("characteristicvaluechanged",this.#r.bind(this)),this.properties.isListening=!1,i.debug("Stopped listening for notifications.",this),e()}catch(e){t(new CharacteristicOperationError(this,"Cannot stop listening to characteristic.",e))}else t(new CharacteristicOperationError(this,"Cannot stop listening to a characteristic that is not yet listened to."))}))}#r(){this.emit("notification",new this.responseType(this.value))}}},976:(e,t,r)=>{const i=r(83),s=r(655),n=r(383);class BluConfigurationError extends s{}e.exports=new class Configuration{#i={acceptAllDevices:!0};#s=i;#n=!0;get scannerConfig(){return this.#i}get deviceType(){return this.#s}get autoListenToNotifiableCharacteristics(){return this.#n}use(e,t){e&&this.useScannerConfig(e),t&&this.useDeviceType(t)}useScannerConfig(e){if("object"!=typeof e)throw new BluConfigurationError('Argument "scannerConfig" must be an object.');this.#i=e}useDeviceType(e){if(!n(e,i))throw new BluConfigurationError('Argument "deviceType" must be a class that is or extends "Device".');this.#s=e}setAutoListenToNotifiableCharacteristics(e){if("boolean"!=typeof e)throw new BluConfigurationError('Argument "value" must be of type "boolean".');this.#n=e}}},257:(e,t,r)=>{const i=r(948),s=r(982),n=r(530),o=r(62),a=r(383),c=r(655);class CharacteristicDescription{name;identifier;type;uuid;descriptors;expectedIndicators;constructor(e,t,r,i,n,c){if("string"!=typeof e)throw new CharacteristicDescriptionConstructionError('Argument "name" must be of type "string".');if("string"!=typeof t)throw new ServiceDescriptionConstructionError('Argument "identifier" must be of type "string".');if(!a(r,s))throw new CharacteristicDescriptionConstructionError('Argument "type" must be a class that is or extends "Characteristic".');if("string"!=typeof i&&"number"!=typeof i)throw new CharacteristicDescriptionConstructionError('Argument "uuid" must be either of type "string" or "number".');if(!o(n)||!n.every((e=>e instanceof DescriptorDescription)))throw new CharacteristicDescriptionConstructionError('Argument "descriptorDescriptions" must be an array of "DescriptorDescription".');if("string"!=typeof c)throw new CharacteristicDescriptionConstructionError('Argument "expectedIndicators" must be either "undefined" or of type "string".');if(!c.match(/^[R-][W-][w-][N-]$/))throw new CharacteristicDescriptionConstructionError('Argument "expectedIndicators" contains a string that is incorrectly formatted.');"string"==typeof i&&(i=i.toLowerCase()),this.name=e,this.identifier=t,this.type=r,this.uuid=i,this.descriptors=n,this.expectedIndicators=c??null}}class DescriptorDescription{name;identifier;type;uuid;constructor(e,t,r,i){if("string"!=typeof e)throw new DescriptorDescriptionConstructionError('Argument "name" must be of type "string".');if("string"!=typeof t)throw new ServiceDescriptionConstructionError('Argument "identifier" must be of type "string".');if(!a(r,n))throw new DescriptorDescriptionConstructionError('Argument "type" must be a class that is or extends "Descriptor".');if("string"!=typeof i&&"number"!=typeof i)throw new DescriptorDescriptionConstructionError('Argument "uuid" must be either of type "string" or "number".');"string"==typeof i&&(i=i.toLowerCase()),this.name=e,this.identifier=t,this.type=r,this.uuid=i}}class ServiceDescriptionConstructionError extends c{}class CharacteristicDescriptionConstructionError extends c{}class DescriptorDescriptionConstructionError extends c{}e.exports={ServiceDescription:class ServiceDescription{name;identifier;type;uuid;characteristics;constructor(e,t,r,s,n){if("string"!=typeof e)throw new ServiceDescriptionConstructionError('Argument "name" must be of type "string".');if("string"!=typeof t)throw new ServiceDescriptionConstructionError('Argument "identifier" must be of type "string".');if(!a(r,i))throw new ServiceDescriptionConstructionError('Argument "type" must be a class that is or extends "Service".');if("string"!=typeof s&&"number"!=typeof s)throw new ServiceDescriptionConstructionError('Argument "uuid" must be either of type "string" or "number".');if(!o(n)||!n.every((e=>e instanceof CharacteristicDescription)))throw new ServiceDescriptionConstructionError('Argument "characteristicDescriptions" must be an array of "CharacteristicDescription".');"string"==typeof s&&(s=s.toLowerCase()),this.name=e,this.identifier=t,this.type=r,this.uuid=s,this.characteristics=n}},CharacteristicDescription,DescriptorDescription}},530:(e,t,r)=>{const i=r(259),s=r(411),n=r(472),o=r(655),a=r(62),c=r(701);class DescriptorOperationError extends o{descriptor;constructor(e,t,r){super(t,r),this.descriptor=e}}e.exports=class Descriptor{characteristic;description;responseType=n;_bluetoothDescriptor;constructor(e,t,r){this.characteristic=e,this.description=r,this._bluetoothDescriptor=t}get uuid(){return this._bluetoothDescriptor.uuid}get value(){return this._bluetoothDescriptor.value}async onceReady(){}readValue(){return new Promise((async(e,t)=>{try{await this.characteristic.service.device.performGATTOperation((()=>this._bluetoothDescriptor.readValue())),s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Read value:`,this.value),e(this.value)}catch(e){t(new DescriptorOperationError(this,"Cannot read value.",e))}}))}read(e){return new Promise((async(t,r)=>{if("string"==typeof e)try{let r=await this.readValue();t(new this.responseType(r)[e])}catch(e){r(e)}else r(new DescriptorOperationError(this,'Argument "responseProperty" must be of type "string".'))}))}write(e){return new Promise((async(t,r)=>{if(!c(e))if(a(e)){if(!e.every((e=>"number"==typeof e)))return void r(new DescriptorOperationError(this,'Argument "value" must be an array of items that are all of type "number".'));e=new Uint8Array(e)}else{if("number"!=typeof e)return void r(new DescriptorOperationError(this,'Argument "value" must be of type "number".'));e=new Uint8Array([e])}try{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Write:`,e),await this.characteristic.service.device.performGATTOperation((()=>this._bluetoothDescriptor.writeValue(e))),t()}catch(e){r(new DescriptorOperationError(this,"Cannot write value.",e))}}))}}},83:(e,t,r)=>{const i=r(259),s=r(411),n=r(948),o=r(982),a=r(530),c=r(893),h=r(655),u=r(122);class DeviceOperationError extends h{}class DeviceConnectionError extends h{}class DeviceBluetoothInterfaceDiscoveryError extends h{}class DeviceBluetoothInterfaceIncompleteError extends h{}class DescriptorDiscoveryError extends h{}e.exports=class Device extends u{id;name;properties;services=[];serviceDescriptions=[];_bluetoothDevice;#o=new c;#a=!1;constructor(e){super(!0),this.id=e.id,this.name=e.name,this._bluetoothDevice=e,this.addChannel("advertised"),this.addChannel("connected"),this.addChannel("connection-lost"),this.addChannel("disconnected"),this.#c()}get characteristics(){let e=[];for(const t of this.services)e.push(...t.characteristics);return e}get isConnected(){return this._bluetoothDevice.gatt.connected}async onceReady(){}connect(e=!0){return new Promise((async(t,r)=>{if("boolean"==typeof e){try{await this._bluetoothDevice.gatt.connect()}catch(e){return void r(new DeviceConnectionError("Could not connect to device.",e))}try{await this.#h(e),this._bluetoothDevice.addEventListener("gattserverdisconnected",this.#u.bind(this),{once:!0}),this._bluetoothDevice.addEventListener("gattserverdisconnected",this.#l.bind(this),{once:!0}),await this.onceReady(),this.emit("connected"),t()}catch(e){r(e)}}else r(new DeviceOperationError('Argument "ensureCompleteBluetoothInterface" must be of type "boolean".'))}))}disconnect(){return new Promise((async(e,t)=>{this.#a=!0;try{await this._bluetoothDevice.gatt.disconnect(),e()}catch(e){t(new DeviceConnectionError("Could not disconnect from device.",e))}this.#a=!1}))}performGATTOperation(e){return this.#o.await(e)}async#c(){if(this.on("connected",(()=>{i.log("Connected.",this),s.emit("device-connected",this)})),this.on("connection-lost",(()=>{i.warn("Connection lost.",this),s.emit("device-connection-lost",this)})),this.on("disconnected",(()=>{i.log("Disconnected.",this),s.emit("device-disconnected",this)})),"function"==typeof this._bluetoothDevice.watchAdvertisements)try{this._bluetoothDevice.addEventListener("advertisementreceived",(e=>{this.emit("advertised",e)})),await this._bluetoothDevice.watchAdvertisements()}catch(e){i.warn(new DeviceOperationError("Could not start watching for advertisements.",e))}}async#h(e){return new Promise((async(t,s)=>{try{let s=!1;for(const e of this.serviceDescriptions){let t;try{t=new e.type(this,await this._bluetoothDevice.gatt.getPrimaryService(e.uuid),e),e.type!==n&&(this[t.description.identifier]=t),this.services.push(t)}catch(t){s=!0,i.warn(`Could not discover "${e.name}".`,this)}if(t)for(const r of e.characteristics){let n;try{n=new r.type(t,await t._bluetoothService.getCharacteristic(r.uuid),r),r.type!==o&&(t[n.description.identifier]=n),t.characteristics.push(n)}catch(t){s=!0,i.warn(`Could not discover "${r.name}" in "${e.name}".`,this)}if(n)for(const e of r.descriptors){let t;try{t=new e.type(n,await n._bluetoothCharacteristic.getDescriptor(e.uuid),e),e.type!==a&&(n[t.description.identifier]=t),n.descriptors.push(t)}catch(t){s=!0,i.warn(`Could not discover "${e.name}" in "${r.name}".`,this)}}}}if(e&&s)throw new DeviceBluetoothInterfaceIncompleteError('The device’s Bluetooth interface is incomplete. Make sure that your service descriptions are correct or set the argument "ensureCompleteInterface" to "false" when calling"device.connect()" to ignore this error.');let h=await this._bluetoothDevice.gatt.getPrimaryServices();for(let e of h){e=new n(this,e),this.services.find((t=>t.uuid===e.uuid))||this.services.push(e);let t=await e._bluetoothService.getCharacteristics();for(let r of t){r=new o(e,r),e.characteristics.find((e=>e.uuid===r.uuid))||e.characteristics.push(r);try{var c=await r._bluetoothCharacteristic.getDescriptors()}catch(e){if("NotFoundError"!==e.name)throw new DescriptorDiscoveryError(`Could not discover descriptors of characteristic with UUID "${r.uuid}".`,e);c=[]}for(let e of c)e=new a(r,e),r.descriptors.find((t=>t.uuid===e.uuid))||r.descriptors.push(e)}}const{autoListenToNotifiableCharacteristics:u}=r(976);for(const e of this.services){for(const t of e.characteristics){t.properties.notify&&u&&await t.startListeningForNotifications();for(const e of t.descriptors)await e.onceReady();await t.onceReady()}await e.onceReady()}t()}catch(e){s(new DeviceBluetoothInterfaceDiscoveryError("Could not discover the device’s Bluetooth interface.",e))}}))}#l(){this.#a||this.emit("connection-lost")}#u(){this.emit("disconnected")}}},893:(e,t,r)=>{const i=r(122),s=r(655);class GATTOperationQueueError extends s{}class GATTOperationError extends s{}e.exports=class GATTOperationQueue extends i{#d=5e3;#p=!1;get isBusy(){return this.#p}await(e){return new Promise((async(t,r)=>{if("function"!=typeof e)return void r(new GATTOperationQueueError('Argument "callback" must be of type "function".'));await this.#f();let i=setTimeout((()=>{r(new GATTOperationError(`GATT operation timed out after ${this.#d} ms.`))}),this.#d);this.#p=!0,this.emit("gatt-operation-started"),e().then((e=>{t(e)})).catch((e=>{r(e)})).finally((()=>{clearTimeout(i),this.#p=!1,this.emit("gatt-operation-finished")}))}))}#f(){return new Promise((e=>{this.#p?this.once("gatt-operation-finished",e):e()}))}}},259:(e,t,r)=>{const i=r(148);e.exports=new i},4:(e,t,r)=>{const i=r(472),s=r(655),n=r(701);class RequestConstructionError extends s{}e.exports=class Request{responseType=i;data;constructor(...e){if(0===e.length)throw new RequestConstructionError('Argument "data" is required.');if(n(e[0])&&void 0===e[1])this.data=e[0];else{if(!e.every((e=>"number"==typeof e)))throw new RequestConstructionError('Argument "data" must be an array of items that are all of type "number".');this.data=new Uint8Array(e)}}}},472:(e,t,r)=>{const i=r(655),s=r(701);class ResponseConstructionError extends i{}e.exports=class Response{data;constructor(e){if(null!=e&&!s(e))throw new ResponseConstructionError(`Argument "data" must be either "undefined", "null" or a concrete type of "TypedArray". Got "${e?.constructor.name}" instead.`);this.data=e??null}static validatorFunction(e){return!0}}},812:(e,t,r)=>{const i=r(411),s=r(655);class ScannerError extends s{}e.exports=new class Scanner{getDevice(){return new Promise((async(e,t)=>{if(i.isSupported)try{const{scannerConfig:t,deviceType:i}=r(976);let s=await globalThis.navigator.bluetooth.requestDevice(t);s=void 0===s?null:new i(s),e(s)}catch(r){"NotFoundError"===r.name?e(null):t(new ScannerError("An error occurred.",r))}else t(new s("Blu is not compatible with this browser."))}))}getPairedDevices(){return new Promise((async(e,t)=>{if("function"==typeof globalThis.navigator?.bluetooth?.getDevices)try{e(await globalThis.navigator.bluetooth.getDevices())}catch(e){t(new ScannerError("An error occurred.",e))}else t(new ScannerError("This feature is not supported by this browser."))}))}}},948:(e,t,r)=>{const i=r(122);e.exports=class Service extends i{device;description;characteristics;_bluetoothService;constructor(e,t,r){super(),this.device=e,this.description=r,this.characteristics=[],this._bluetoothService=t}get uuid(){return this._bluetoothService.uuid}async onceReady(){}}},345:e=>{e.exports="1.1.0"},655:e=>{class BluError extends Error{constructor(e,t){super(e,{cause:t}),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,t&&(this.message+=` // ${t.name}: ${t.message}`)}}e.exports=BluError},122:(e,t,r)=>{const i=r(259),s=r(655);class EventEmitterError extends s{}e.exports=class EventEmitter{#g;#m=new Map;#w=new Set;constructor(e=!1){if("boolean"!=typeof e)throw new EventEmitterError('Argument "strictMode" must be of type "boolean".');this.#g=e}emit(e,...t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(this.#g&&!this.#m.has(e))throw new EventEmitterError(`"${e}" is not a valid channel. Add it manually or disable strict mode.`);if(this.#m.has(e)||this.#m.set(e,new Set),this.#w.has(e))i.debug(`Suppressed event for the muted channel "${e}".`,this);else for(const r of this.#m.get(e))r(...t)}on(e,t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if("function"!=typeof t)throw new EventEmitterError('Argument "callback" must be of type "function".');if(this.#g&&!this.#m.has(e))throw new EventEmitterError(`"${e}" is not a valid channel. Add it manually or disable strict mode.`);this.#m.has(e)||this.#m.set(e,new Set),this.#m.set(e,this.#m.get(e).add(t))}once(e,t){let r=()=>{this.off(e,r),t()};this.on(e,r)}muteChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(!this.#m.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#w.has(e)?i.warn(`The channel "${e}" is already muted.`,this):this.#w.add(e)}unmuteChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(!this.#m.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#w.has(e)?this.#w.delete(e):i.warn(`The channel "${e}" is already unmuted.`,this)}off(e,t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if("function"!=typeof t)throw new EventEmitterError('Argument "callback" must be of type "function".');if(!this.#m.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#m.get(e).delete(t)||i.warn(`Cannot remove the function in argument "callback", as it is not yet registered for "${e}".`,this)}addChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');this.#m.has(e)?i.warn(`The channel "${e}" already exists.`,this):this.#m.set(e,new Set)}removeChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');this.#m.has(e)?this.#m.delete(e):i.warn(`The channel "${e}" does not exist.`,this)}removeAllListeners(e){if(void 0!==e&&"string"!=typeof e)throw new EventEmitterError('Argument "channel" must be either "undefined" or of type "string".');e?this.#m.has(e)?this.#m.set(e,new Set):i.warn(`The channel "${e}" does not exist.`,this):this.#m.clear()}}},62:e=>{e.exports=function(e){return Array.isArray(e)}},383:e=>{e.exports=function(e,t){return e.prototype instanceof t||e===t}},701:e=>{e.exports=function(e){return ArrayBuffer.isView(e)}},148:(e,t,r)=>{const i=r(655),s=new Intl.DateTimeFormat("en-US",{hour12:!1,hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3});class LoggerError extends i{}e.exports=class Logger{includeTimestamps=!1;includeLevelNames=!1;#v="";#y=0;#b=console;#E=!0;get isEnabled(){return this.#E}get target(){return this.#b}enable(){this.#E&&this.warn("Already enabled.",this),this.#E=!0}disable(){this.#E||this.warn("Already disabled.",this),this.#E=!1}setPrefix(e){if("string"!=typeof e)throw new LoggerError('Argument "prefix" must be of type "string".');this.#v=e}setPrefix(e){if("string"!=typeof e)throw new LoggerError('Argument "prefix" must be of type "string".');this.#v=e}setLevel(e){if("string"!=typeof e||!["debug","log","warn","error"].includes(e))throw new LoggerError('Argument "level" must be of type "string" and be one of the following: "debug", "log", "warn" or "error".');switch(e){case"debug":this.#y=0;break;case"log":this.#y=1;break;case"warn":this.#y=2;break;case"error":this.#y=3}}setTarget(e){if("object"!=typeof e||"function"!=typeof e.log||"function"!=typeof e.debug||"function"!=typeof e.warn||"function"!=typeof e.error)throw new LoggerError('Argument "consoleLike" must be an object that implements the following functions: "log", "debug", "warn" and "error".');this.#b=e}debug(e,t){!this.#E||this.#y>0||this.#b.debug(this.#C(t,"debug")+e)}log(e,t){!this.#E||this.#y>1||this.#b.log(this.#C(t,"log")+e)}warn(e,t){!this.#E||this.#y>2||this.#b.warn(this.#C(t,"warn")+e)}error(e,t){this.#E&&this.#b.error(this.#C(t,"error")+e)}#C(e,t){let r="";return this.includeTimestamps&&(r+=`[${s.format(Date.now())}] `),this.includeLevelNames&&(r+=`[${t}] `),this.#v.length>0&&(r+=`[${this.#v}] `),"string"==typeof e?r+=`${e}: `:e?.constructor?r+=`${e.constructor.name}: `:e?.name&&(r+=`${e.name}: `),r}}}},t={},r=function r(i){var s=t[i];if(void 0!==s)return s.exports;var n=t[i]={exports:{}};return e[i](n,n.exports,r),n.exports}(920),r;var e,t,r}));
//# sourceMappingURL=blu.umd.min.js.map