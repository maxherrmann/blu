/**
 * Blu 1.4.1 (Minified CommonJS Module) | Tue, 25 Apr 2023 19:59:21 GMT
 * Copyright (c) 2023 Max Herrmann
 * https://github.com/maxherrmann/blu/blob/main/LICENSE
 */
(()=>{"use strict";var e={d:(t,r)=>{for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>l});class BluError extends Error{constructor(e,t){super(e,{cause:t}),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,t&&(this.message+=` // ${t.name}: ${t.message}`)}}const r=new Intl.DateTimeFormat("en-US",{hour12:!1,hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3});class LoggerError extends BluError{}const i=new class Logger{includeTimestamps=!1;includeLevelNames=!1;#e="";#t=0;#r=console;#i=!0;get isEnabled(){return this.#i}get target(){return this.#r}enable(){this.#i&&this.warn("Already enabled.",this),this.#i=!0}disable(){this.#i||this.warn("Already disabled.",this),this.#i=!1}setPrefix(e){if("string"!=typeof e)throw new LoggerError('Argument "prefix" must be of type "string".');this.#e=e}setPrefix(e){if("string"!=typeof e)throw new LoggerError('Argument "prefix" must be of type "string".');this.#e=e}setLevel(e){if("string"!=typeof e||!["debug","log","warn","error"].includes(e))throw new LoggerError('Argument "level" must be of type "string" and be one of the following: "debug", "log", "warn" or "error".');switch(e){case"debug":this.#t=0;break;case"log":this.#t=1;break;case"warn":this.#t=2;break;case"error":this.#t=3}}setTarget(e){if("object"!=typeof e||"function"!=typeof e.log||"function"!=typeof e.debug||"function"!=typeof e.warn||"function"!=typeof e.error)throw new LoggerError('Argument "consoleLike" must be an object that implements the following functions: "log", "debug", "warn" and "error".');this.#r=e}debug(e,t){!this.#i||this.#t>0||this.#r.debug(this.#s(t,"debug")+e)}log(e,t){!this.#i||this.#t>1||this.#r.log(this.#s(t,"log")+e)}warn(e,t){!this.#i||this.#t>2||this.#r.warn(this.#s(t,"warn")+e)}error(e,t){this.#i&&this.#r.error(this.#s(t,"error")+e)}#s(e,t){let i="";return this.includeTimestamps&&(i+=`[${r.format(Date.now())}] `),this.includeLevelNames&&(i+=`[${t}] `),this.#e.length>0&&(i+=`[${this.#e}] `),"string"==typeof e?i+=`${e}: `:e?.constructor?i+=`${e.constructor.name}: `:e?.name&&(i+=`${e.name}: `),i}};class EventEmitter{#n;#o=new Map;#a=new Set;constructor(e=!1){if("boolean"!=typeof e)throw new EventEmitterError('Argument "strictMode" must be of type "boolean".');this.#n=e}emit(e,...t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(this.#n&&!this.#o.has(e))throw new EventEmitterError(`"${e}" is not a valid channel. Add it manually or disable strict mode.`);if(this.#o.has(e)||this.#o.set(e,new Set),this.#a.has(e))i.debug(`Suppressed event for the muted channel "${e}".`,this);else for(const r of this.#o.get(e))r(...t)}on(e,t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if("function"!=typeof t)throw new EventEmitterError('Argument "callback" must be of type "function".');if(this.#n&&!this.#o.has(e))throw new EventEmitterError(`"${e}" is not a valid channel. Add it manually or disable strict mode.`);this.#o.has(e)||this.#o.set(e,new Set),this.#o.set(e,this.#o.get(e).add(t))}once(e,t){let r=(...i)=>{this.off(e,r),t(...i)};this.on(e,r)}muteChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(!this.#o.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#a.has(e)?i.warn(`The channel "${e}" is already muted.`,this):this.#a.add(e)}unmuteChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if(!this.#o.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#a.has(e)?this.#a.delete(e):i.warn(`The channel "${e}" is already unmuted.`,this)}off(e,t){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');if("function"!=typeof t)throw new EventEmitterError('Argument "callback" must be of type "function".');if(!this.#o.has(e))throw new EventEmitterError(`"${e}" is not a valid channel.`);this.#o.get(e).delete(t)||i.warn(`Cannot remove the function in argument "callback", as it is not yet registered for "${e}".`,this)}addChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');this.#o.has(e)?i.warn(`The channel "${e}" already exists.`,this):this.#o.set(e,new Set)}removeChannel(e){if("string"!=typeof e)throw new EventEmitterError('Argument "channel" must be of type "string".');this.#o.has(e)?this.#o.delete(e):i.warn(`The channel "${e}" does not exist.`,this)}removeAllListeners(e){if(void 0!==e&&"string"!=typeof e)throw new EventEmitterError('Argument "channel" must be either "undefined" or of type "string".');e?this.#o.has(e)?this.#o.set(e,new Set):i.warn(`The channel "${e}" does not exist.`,this):this.#o.clear()}}class EventEmitterError extends BluError{}const s=new class Bluetooth extends EventEmitter{#c=new Set;#h=!1;constructor(){super(!0),this.addChannel("bluetooth-enabled"),this.addChannel("bluetooth-disabled"),this.addChannel("device-connected"),this.addChannel("device-connection-lost"),this.addChannel("device-disconnected"),this.isSupported&&(globalThis.navigator.bluetooth.addEventListener("availabilitychanged",(e=>{this.emit(e.value?"bluetooth-enabled":"bluetooth-disabled")})),this.on("bluetooth-disabled",(()=>{this.#c.clear()})),this.on("device-connected",(e=>{this.#c.add(e)})),this.on("device-disconnected",(e=>{this.#c.delete(e)})))}get isSupported(){return!!globalThis.navigator?.bluetooth}get isDataTransferLoggingEnabled(){return this.#h}get connectedDevices(){return Array.from(this.#c)}get connectedDevice(){return this.connectedDevices[this.connectedDevices.length-1]??null}isAvailable(){return new Promise((e=>{this.isSupported?globalThis.navigator.bluetooth.getAvailability().then((t=>{e(t)})):e(!1)}))}enableDataTransferLogging(){this.#h=!0}disableDataTransferLogging(){this.#h=!1}};class Service extends EventEmitter{device;description;characteristics;_bluetoothService;constructor(e,t,r){super(),this.device=e,this.description=r,this.characteristics=[],this._bluetoothService=t}get uuid(){return this._bluetoothService.uuid}async onceReady(){}}function n(e){return ArrayBuffer.isView(e)}class Response{data;constructor(e){if(null!=e&&!n(e))throw new ResponseConstructionError(`Argument "data" must be either "undefined", "null" or a concrete type of "TypedArray". Got "${e?.constructor.name}" instead.`);this.data=e??null}static validatorFunction(e){return!0}}class ResponseConstructionError extends BluError{}class Request{responseType=Response;data;constructor(...e){if(0===e.length)throw new RequestConstructionError('Argument "data" is required.');if(n(e[0])&&void 0===e[1])this.data=e[0];else{if(!e.every((e=>"number"==typeof e)))throw new RequestConstructionError('Argument "data" must be an array of items that are all of type "number".');this.data=new Uint8Array(e)}}}class RequestConstructionError extends BluError{}function o(e){return Array.isArray(e)}class Characteristic extends EventEmitter{service;description;properties;descriptors;responseType=Response;_bluetoothCharacteristic;constructor(e,t,r){super(),this.service=e,this.description=r,this.properties=new CharacteristicProperties(t.properties),this.descriptors=[],this._bluetoothCharacteristic=t,this.on("notification",(e=>{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Notification received:`,e)}))}get uuid(){return this._bluetoothCharacteristic.uuid}get value(){return this._bluetoothCharacteristic.value}get hasExpectedProperties(){return this.properties.string===this.description.expectedIndicators}async onceReady(){}readValue(){return new Promise((async(e,t)=>{if(this.properties.read)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.readValue())),s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Read value:`,this.value),e(this.value)}catch(e){t(new CharacteristicOperationError(this,"Cannot read value.",e))}else t(new CharacteristicOperationError(this,"Cannot read from a non-readable characteristic."))}))}read(e){return new Promise((async(t,r)=>{if("string"==typeof e)try{let r=await this.readValue();t(new this.responseType(r)[e])}catch(e){r(e)}else r(new CharacteristicOperationError(this,'Argument "responseProperty" must be of type "string".'))}))}write(e,t=!1){return new Promise((async(r,a)=>{if(!t||this.properties.writeWithoutResponse)if(t||this.properties.write){if(!n(e))if(o(e)){if(!e.every((e=>"number"==typeof e)))return void a(new CharacteristicOperationError(this,'Argument "value" must be an array of items that are all of type "number".'));e=new Uint8Array(e)}else{if("number"!=typeof e)return void a(new CharacteristicOperationError(this,'Argument "value" must be of type "number".'));e=new Uint8Array([e])}try{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Write:`,e),t?await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.writeValueWithoutResponse(e))):await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.writeValueWithResponse(e))),r()}catch(e){a(new CharacteristicOperationError(this,"Cannot write value.",e))}}else a(new CharacteristicOperationError(this,"Cannot write to a non-writable characteristic."));else a(new CharacteristicOperationError(this,"Cannot write without response to a characteristic that is not writable without response."))}))}request(e,t=a){return new Promise((async(r,n)=>{if(!(e instanceof Request))return void n(new CharacteristicOperationError(this,`Argument "request" must be a valid instance of "Request". Got "${e?.constructor.name}".`));if(null!=t&&"number"!=typeof t)return void n(new CharacteristicOperationError(this,'Argument "timeout" must be either "undefined", "null" or of type "number". '));s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Request:`,e);let o=t=>{e.responseType.validatorFunction(t)&&(clearTimeout(a),this.off("notification",o),r(new e.responseType(t.data)))};if(this.on("notification",o),t)var a=setTimeout((()=>{this.off("notification",o),n(new NotificationTimeoutError(`Did not receive an expected notification from the device within ${t} ms.`))}),t);this.write(e.data).catch((e=>{clearTimeout(a),this.off("notification",o),n(new CharacteristicOperationError(this,"Cannot request from characteristic.",e))}))}))}requestAll(e,t=a){return new Promise((async(r,i)=>{if(o(e)&&e.every((e=>e instanceof Request)))if(null==t||"number"==typeof t)try{let i=[];for(const r of e)i.push(await this.request(r,t));r(i)}catch(e){i(e)}else i(new CharacteristicOperationError(this,'Argument "timeout" must be either "undefined", "null" or of type "number". '));else i(new CharacteristicOperationError(this,'Argument "requests" must be an array of instances of "Request".'))}))}startListeningForNotifications(){return new Promise((async(e,t)=>{if(this.properties.notify)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.startNotifications())),this._bluetoothCharacteristic.addEventListener("characteristicvaluechanged",this.#u.bind(this)),this.properties.isListening=!0,i.debug("Started listening for notifications.",this),e()}catch(e){t(new CharacteristicOperationError(this,"Cannot start listening to characteristic.",e))}else t(new CharacteristicOperationError(this,"Cannot start listening to a non-notifying characteristic."))}))}stopListeningForNotifications(){return new Promise((async(e,t)=>{if(this.properties.isListening)try{await this.service.device.performGATTOperation((()=>this._bluetoothCharacteristic.stopNotifications())),this._bluetoothCharacteristic.removeEventListener("characteristicvaluechanged",this.#u.bind(this)),this.properties.isListening=!1,i.debug("Stopped listening for notifications.",this),e()}catch(e){t(new CharacteristicOperationError(this,"Cannot stop listening to characteristic.",e))}else t(new CharacteristicOperationError(this,"Cannot stop listening to a characteristic that is not yet listened to."))}))}#u(){this.emit("notification",new this.responseType(this.value))}}const a=5e3;class CharacteristicProperties{read;write;writeWithoutResponse;notify;constructor(e){this.read=e.read,this.write=e.write,this.writeWithoutResponse=e.writeWithoutResponse,this.notify=e.notify,this.notify&&(this.isListening=!1)}get string(){return this.toString()}toString(){return[this.read?"R":"-",this.write?"W":"-",this.writeWithoutResponse?"w":"-",this.notify?"N":"-"].join("")}}class CharacteristicOperationError extends BluError{characteristic;constructor(e,t,r){super(t,r),this.characteristic=e}}class NotificationTimeoutError extends BluError{}class Descriptor{characteristic;description;responseType=Response;_bluetoothDescriptor;constructor(e,t,r){this.characteristic=e,this.description=r,this._bluetoothDescriptor=t}get uuid(){return this._bluetoothDescriptor.uuid}get value(){return this._bluetoothDescriptor.value}async onceReady(){}readValue(){return new Promise((async(e,t)=>{try{await this.characteristic.service.device.performGATTOperation((()=>this._bluetoothDescriptor.readValue())),s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Read value:`,this.value),e(this.value)}catch(e){t(new DescriptorOperationError(this,"Cannot read value.",e))}}))}read(e){return new Promise((async(t,r)=>{if("string"==typeof e)try{let r=await this.readValue();t(new this.responseType(r)[e])}catch(e){r(e)}else r(new DescriptorOperationError(this,'Argument "responseProperty" must be of type "string".'))}))}write(e){return new Promise((async(t,r)=>{if(!n(e))if(o(e)){if(!e.every((e=>"number"==typeof e)))return void r(new DescriptorOperationError(this,'Argument "value" must be an array of items that are all of type "number".'));e=new Uint8Array(e)}else{if("number"!=typeof e)return void r(new DescriptorOperationError(this,'Argument "value" must be of type "number".'));e=new Uint8Array([e])}try{s.isDataTransferLoggingEnabled&&i.target.debug(`${this.description.name}: Write:`,e),await this.characteristic.service.device.performGATTOperation((()=>this._bluetoothDescriptor.writeValue(e))),t()}catch(e){r(new DescriptorOperationError(this,"Cannot write value.",e))}}))}}class DescriptorOperationError extends BluError{descriptor;constructor(e,t,r){super(t,r),this.descriptor=e}}class GATTOperationQueue extends EventEmitter{#l=5e3;#d=!1;get isBusy(){return this.#d}await(e){return new Promise((async(t,r)=>{if("function"!=typeof e)return void r(new GATTOperationQueueError('Argument "callback" must be of type "function".'));await this.#p();let i=setTimeout((()=>{r(new GATTOperationError(`GATT operation timed out after ${this.#l} ms.`))}),this.#l);this.#d=!0,this.emit("gatt-operation-started"),e().then((e=>{t(e)})).catch((e=>{r(e)})).finally((()=>{clearTimeout(i),this.#d=!1,this.emit("gatt-operation-finished")}))}))}#p(){return new Promise((e=>{this.#d?this.once("gatt-operation-finished",e):e()}))}}class GATTOperationQueueError extends BluError{}class GATTOperationError extends BluError{}function c(e,t){return e.prototype instanceof t||e===t}class Description{uuid;identifier;name;constructor(e,t=null,r="Unspecified Entity"){if("string"!=typeof e&&"number"!=typeof e)throw new DescriptionConstructionError('Argument "uuid" must be either of type "string" or "number".');if("string"==typeof e&&(e=e.toLowerCase()),null!==t&&"string"!=typeof t)throw new DescriptionConstructionError('Argument "identifier" must be either "null" or of type "string".');if("string"!=typeof r)throw new DescriptionConstructionError('Argument "name" must be of type "string".');this.uuid=e,this.identifier=t,this.name=r}}class ServiceDescription extends Description{type;characteristics;constructor(e,t,r="Unspecified Service",i=Service,s=[]){if(super(e,t,r),!c(i,Service))throw new ServiceDescriptionConstructionError('Argument "type" must be a class that is or extends "Service".');if(!o(s)||!s.every((e=>e instanceof CharacteristicDescription)))throw new ServiceDescriptionConstructionError('Argument "characteristicDescriptions" must be an array of "CharacteristicDescription".');this.type=i,this.characteristics=s}}class CharacteristicDescription extends Description{type;descriptors;expectedIndicators;constructor(e,t,r="Unspecified Characteristic",i=Characteristic,s=[],n=null){if(super(e,t,r),!c(i,Characteristic))throw new CharacteristicDescriptionConstructionError('Argument "type" must be a class that is or extends "Characteristic".');if(!o(s)||!s.every((e=>e instanceof DescriptorDescription)))throw new CharacteristicDescriptionConstructionError('Argument "descriptorDescriptions" must be an array of "DescriptorDescription".');if(null!==n&&"string"!=typeof n)throw new CharacteristicDescriptionConstructionError('Argument "expectedIndicators" must be either "null" or of type "string".');if("string"==typeof n&&!n.match(/^[R-][W-][w-][N-]$/))throw new CharacteristicDescriptionConstructionError('Argument "expectedIndicators" contains a string that is incorrectly formatted.');this.type=i,this.descriptors=s,this.expectedIndicators=n??null}}class DescriptorDescription extends Description{type;constructor(e,t=null,r="Unspecified Descriptor",i=Descriptor){if(super(e,t,r),!c(i,Descriptor))throw new DescriptorDescriptionConstructionError('Argument "type" must be a class that is or extends "Descriptor".');this.type=i}}class DescriptionConstructionError extends BluError{}class ServiceDescriptionConstructionError extends BluError{}class CharacteristicDescriptionConstructionError extends BluError{}class DescriptorDescriptionConstructionError extends BluError{}class Device extends EventEmitter{id;name;properties;services=[];serviceDescriptions=[];_bluetoothDevice;#f=new GATTOperationQueue;#g=!1;constructor(e){super(!0),this.id=e.id,this.name=e.name,this._bluetoothDevice=e,this.addChannel("advertised"),this.addChannel("connected"),this.addChannel("connection-lost"),this.addChannel("disconnected"),this.#m()}get characteristics(){let e=[];for(const t of this.services)e.push(...t.characteristics);return e}get isConnected(){return this._bluetoothDevice.gatt.connected}async onceReady(){}connect(){return new Promise((async(e,t)=>{try{await this._bluetoothDevice.gatt.connect()}catch(e){return void t(new DeviceConnectionError("Could not connect to device.",e))}try{await this.#w(),this._bluetoothDevice.addEventListener("gattserverdisconnected",this.#v.bind(this),{once:!0}),this._bluetoothDevice.addEventListener("gattserverdisconnected",this.#y.bind(this),{once:!0}),await this.onceReady(),this.emit("connected"),e()}catch(e){t(e)}}))}disconnect(){return new Promise((async(e,t)=>{this.#g=!0;try{await this._bluetoothDevice.gatt.disconnect(),e()}catch(e){t(new DeviceConnectionError("Could not disconnect from device.",e))}this.#g=!1}))}performGATTOperation(e){return this.#f.await(e)}async#m(){if(this.on("connected",(()=>{i.log("Connected.",this),s.emit("device-connected",this)})),this.on("connection-lost",(()=>{i.warn("Connection lost.",this),s.emit("device-connection-lost",this)})),this.on("disconnected",(()=>{i.log("Disconnected.",this),s.emit("device-disconnected",this)})),"function"==typeof this._bluetoothDevice.watchAdvertisements)try{this._bluetoothDevice.addEventListener("advertisementreceived",(e=>{this.emit("advertised",e)})),await this._bluetoothDevice.watchAdvertisements()}catch(e){i.warn(new DeviceOperationError("Could not start watching for advertisements.",e))}}async#w(){return new Promise((async(e,t)=>{try{let t=!1;for(const e of this.serviceDescriptions){let r;try{r=new e.type(this,await this._bluetoothDevice.gatt.getPrimaryService(e.uuid),e),r.description.identifier&&(this[r.description.identifier]=r),this.services.push(r)}catch(r){t=!0,i.warn(`Could not discover "${e.name}" (${e.uuid}).`,this)}if(r)for(const s of e.characteristics){let n;try{n=new s.type(r,await r._bluetoothService.getCharacteristic(s.uuid),s),n.description.identifier&&(r[n.description.identifier]=n),r.characteristics.push(n)}catch(r){t=!0,i.warn(`Could not discover "${s.name}" (${s.uuid}) in "${e.name}" (${e.uuid}).`,this)}if(n)for(const e of s.descriptors){let r;try{r=new e.type(n,await n._bluetoothCharacteristic.getDescriptor(e.uuid),e),r.description.identifier&&(n[r.description.identifier]=r),n.descriptors.push(r)}catch(r){t=!0,i.warn(`Could not discover "${e.name}" (${e.uuid}) in "${s.name}" (${s.uuid}).`,this)}}}}if(h.ensureCompleteDeviceBluetoothInterface&&t)throw new DeviceBluetoothInterfaceIncompleteError('The device’s Bluetooth interface is incomplete. Make sure that your service descriptions are correct or configure Blu to ignore incomplete device Bluetooth interfaces by setting the configuration property "ensureCompleteDeviceBluetoothInterface" to "false" before calling "device.connect()".');let s=await this._bluetoothDevice.gatt.getPrimaryServices();for(let e of s){e=new Service(this,e,new ServiceDescription(e.uuid)),this.services.find((t=>t.uuid===e.uuid))||this.services.push(e);let t=await e._bluetoothService.getCharacteristics();for(let i of t){i=new Characteristic(e,i,new CharacteristicDescription(i.uuid)),e.characteristics.find((e=>e.uuid===i.uuid))||e.characteristics.push(i);try{var r=await i._bluetoothCharacteristic.getDescriptors()}catch(e){if("NotFoundError"!==e.name)throw new DescriptorDiscoveryError(`Could not discover descriptors of characteristic with UUID "${i.uuid}".`,e);r=[]}for(let e of r)e=new Descriptor(i,e,new DescriptorDescription(e.uuid)),i.descriptors.find((t=>t.uuid===e.uuid))||i.descriptors.push(e)}}for(const e of this.services){for(const t of e.characteristics){t.properties.notify&&h.autoListenToNotifiableCharacteristics&&await t.startListeningForNotifications();for(const e of t.descriptors)await e.onceReady();await t.onceReady()}await e.onceReady()}e()}catch(e){t(new DeviceBluetoothInterfaceDiscoveryError("Could not discover the device’s Bluetooth interface.",e))}}))}#y(){this.#g||this.emit("connection-lost")}#v(){this.emit("disconnected")}}class DeviceOperationError extends BluError{}class DeviceConnectionError extends BluError{}class DeviceBluetoothInterfaceDiscoveryError extends BluError{}class DeviceBluetoothInterfaceIncompleteError extends BluError{}class DescriptorDiscoveryError extends BluError{}class BluConfigurationError extends BluError{}const h=new class Configuration{#b;#E;#C;#D;constructor(){this.restoreDefaults()}get scannerConfig(){return this.#b}get deviceType(){return this.#E}get ensureCompleteDeviceBluetoothInterface(){return this.#C}get autoListenToNotifiableCharacteristics(){return this.#D}restoreDefaults(){this.#b={acceptAllDevices:!0},this.#E=Device,this.#C=!0,this.#D=!0}use(e,t){e&&this.useScannerConfig(e),t&&this.useDeviceType(t)}useScannerConfig(e){if("object"!=typeof e)throw new BluConfigurationError('Argument "scannerConfig" must be an object.');this.#b=e}useDeviceType(e){if(!c(e,Device))throw new BluConfigurationError('Argument "deviceType" must be a class that is or extends "Device".');this.#E=e}set(e){if("object"!=typeof e)throw new BluConfigurationError('Argument "configuration" must be an object.');if(!Object.getOwnPropertyNames(e).every((e=>["ensureCompleteDeviceBluetoothInterface","autoListenToNotifiableCharacteristics"].includes(e))))throw new BluConfigurationError('Argument "configuration" must contain an object with valid configuration options.');if(Object.hasOwn(e,"ensureCompleteDeviceBluetoothInterface")){if("boolean"!=typeof e.ensureCompleteDeviceBluetoothInterface)throw new BluConfigurationError('Configuration property "ensureCompleteDeviceBluetoothInterface" must be of type "boolean".');this.#C=e.ensureCompleteDeviceBluetoothInterface}if(Object.hasOwn(e,"autoListenToNotifiableCharacteristics")){if("boolean"!=typeof e.autoListenToNotifiableCharacteristics)throw new BluConfigurationError('Configuration property "autoListenToNotifiableCharacteristics" must be of type "boolean".');this.#D=e.autoListenToNotifiableCharacteristics}}};class ScannerError extends BluError{}const u=new class Scanner{getDevice(){return new Promise((async(e,t)=>{if(s.isSupported)try{let t=await globalThis.navigator.bluetooth.requestDevice(h.scannerConfig);t=void 0===t?null:new h.deviceType(t),e(t)}catch(r){"NotFoundError"===r.name?e(null):t(new ScannerError("An error occurred.",r))}else t(new BluError("Blu is not compatible with this browser."))}))}getPairedDevices(){return new Promise((async(e,t)=>{if("function"==typeof globalThis.navigator?.bluetooth?.getDevices)try{e(await globalThis.navigator.bluetooth.getDevices())}catch(e){t(new ScannerError("An error occurred.",e))}else t(new ScannerError("This feature is not supported by this browser."))}))}},l={bluetooth:s,configuration:h,logger:i,scanner:u,version:"1.4.1",ServiceDescription,CharacteristicDescription,DescriptorDescription,Service,Characteristic,Descriptor,Device,Request,Response,BluError};module.exports=t.default})();
//# sourceMappingURL=blu.min.cjs.map